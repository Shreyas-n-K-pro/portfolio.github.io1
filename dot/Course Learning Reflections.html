<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Course Learning Reflections</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      line-height: 1.6;
      margin: 20px;
      background-color: #f9f9f9;
      color: #333;
    }
    h3, h4 {
      color: blue;
    }
    h3 {
      font-size: 24px;
      margin-bottom: 10px;
      border-bottom: 2px solid #3498db;
      padding-bottom: 5px;
    }
    h4 {
      font-size: 20px;
      margin-top: 20px;
    }
    h5 {
      font-size: 18px;
      margin-top: 10px;
      margin-bottom: 5px;
    }
    p {
      margin: 5px 0;
    }
    ul {
      margin-left: 20px;
    }
    ul li {
      margin: 5px 0;
      list-style-type: disc;
    }
    .container {
      max-width: 800px;
      margin: 0 auto;
      background: #ffffff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }
  </style>
</head>
<body>
  <div class="container">
    <h3>Course Learning Reflections</h3>
    <h4>&bull; &nbsp;1.What are the kinds of problems we see in the nature? (iteration, recursion, backtracking)</h4>
    <h5>1. Iteration Problems</h5>
    <h5>Examples in Nature</h5>
    <p>Iteration means repeating steps in a loop until the job is done.</p>
    <ul>
      <li>Think of the sun rising and setting every day—it’s a repeating cycle.</li>
      <li>Counting the rings on a tree to know its age—each ring is added one at a time over the years.</li>
    </ul>
    
    <h5>Examples in Coding</h5>
    <ul>
      <li>Going through a list to find the largest number.</li>
      <li>Adding all the numbers in a group (like calculating your total grocery bill).</li>
    </ul>

    <h4>2. Recursion Problems</h4>
    <h5>Examples in Nature</h5>
    <p>Recursion is when a problem solves itself in smaller steps until it’s complete.</p>
    <ul>
      <li>Imagine a tree: A branch splits into smaller branches, which split into even smaller branches.</li>
      <li>Think of how you fold a piece of paper in half repeatedly—it’s the same process over and over.</li>
    </ul>
    
    <h5>Examples in Coding</h5>
    <ul>
      <li>Calculating factorials (e.g., 5! = 5 × 4 × 3 × 2 × 1).</li>
      <li>Finding your way through a family tree or exploring nested folders on your computer.</li>
    </ul>

    <h4>3. Backtracking Problems</h4>
    <h5>Examples in Nature</h5>
    <p>Backtracking is like trial and error: you try a path, and if it doesn’t work, you go back and try another one.</p>
    <ul>
      <li>Picture an ant trying to find food—it explores one path, and if it’s blocked, it turns around and tries a different way.</li>
      <li>Solving a maze: If one route doesn’t work, you go back and try a new direction.</li>
    </ul>
    
    <h5>Examples in Coding</h5>
    <ul>
      <li>Solving puzzles like Sudoku.</li>
      <li>Finding all possible combinations, like arranging letters to form words.</li>
      <li>Figuring out the shortest route on a map.</li>
    </ul>
    <h4>&bull; &nbsp;What is space and time efficiency? Why are they important? Explain the different class of problems and orders of growth</h4>
    <h5>Space and Time Efficiency</h5>
    <p>Time Efficiency is about how fast an algorithm runs. Imagine you’re baking a cake—time efficiency is how quickly you can finish baking.</p>
    <p>Space Efficiency is about how much memory or storage an algorithm uses while running. It’s like how many bowls or tools you need to bake that cake. The fewer, the better.</p>
    
    <h5>Why Are They Important?</h5>
    <ul>
      <li><strong>Save Time:</strong> Faster algorithms mean less waiting.</li>
      <li><strong>Save Memory:</strong> Efficient algorithms don’t use too much computer memory, so your device won’t slow down or crash.</li>
      <li><strong>Handle Bigger Problems:</strong> Efficient algorithms can process large amounts of data without issues.</li>
      <li><strong>Better User Experience:</strong> Nobody likes apps or websites that are slow and laggy.</li>
    </ul>

    <h5>Types of Problems</h5>
    <ul>
      <li><strong>Easy Problems (P):</strong> Problems that computers can solve quickly. For example, sorting a list of names or finding the shortest path on a map.</li>
      <li><strong>Tricky Problems (NP):</strong> Harder to solve but easy to check, like solving a jigsaw puzzle.</li>
      <li><strong>Super Tricky Problems (NP-Complete):</strong> The hardest puzzles. If we figure out a fast way to solve one of them, we can solve many other tricky problems just as fast.</li>
      <li><strong>Impossible Problems (NP-Hard):</strong> Problems so tough that no one knows how to solve them efficiently—or even check the answer easily in some cases.</li>
    </ul>
    <h5>Orders of Growth (How Algorithms Grow as Input Increases)</h5>
    <ul>
      <li><strong>O(1) – Constant Time:</strong> No matter the size, it always takes the same time. Example: Picking the first book from a pile.</li>
      <li><strong>O(log n) – Logarithmic Time:</strong> Grows slowly as input increases. Example: Finding a name in a phone book (binary search).</li>
      <li><strong>O(n) – Linear Time:</strong> Time grows directly with input size. Example: Reading all the books in a stack one by one.</li>
      <li><strong>O(n log n) – Linearithmic Time:</strong> Grows a bit faster, often seen in efficient sorting methods. Example: Sorting your books by size.</li>
      <li><strong>O(n²) – Quadratic Time:</strong> Time grows really fast, usually when there are nested loops. Example: Comparing every book with every other book.</li>
      <li><strong>O(2ⁿ) – Exponential Time:</strong> Time doubles with each new piece of data. Example: Trying every possible combination of books to find the best arrangement.</li>
      <li><strong>O(n!) – Factorial Time:</strong> Time explodes! Example: Arranging 10 books in every possible order (10! = 3,628,800 ways).</li>
    </ul>

    <h4>&bull; &nbsp;3.The hierarchical data and how different tree data structures solve and optimize over the problem scenarios (tree, bst, avl, 2-3, red-black, heap, trie)</h4>
    <h5>1. Basic Tree (Unbalanced Tree)</h5>
    <p><strong>Structure:</strong> A basic tree has nodes connected in a parent-child relationship but doesn't impose any ordering or balancing rules.</p>
    <p><strong>Problem:</strong> Search operations can be inefficient if the tree becomes unbalanced, potentially degrading to a linear structure (like a linked list).</p>
    <p><strong>Optimization:</strong> This is the most straightforward structure but doesn't optimize performance for large datasets.</p>

    <h5>2. Binary Search Tree (BST)</h5>
    <p><strong>Structure:</strong> A BST is a type of tree where each node has at most two children. For any given node, all nodes in the left subtree have smaller values, and all nodes in the right subtree have larger values.</p>
    <p><strong>Problem:</strong> If the tree becomes unbalanced (like a linked list), operations like search, insertion, and deletion can degrade to O(n) time complexity.</p>
    <p><strong>Optimization:</strong> Ideal for ordered data, allowing efficient searching, insertion, and deletion in O(log n) time for balanced trees.</p>

    <h5>3. AVL Tree (Adelson-Velsky and Landis Tree)</h5>
    <p><strong>Structure:</strong> An AVL tree is a self-balancing BST where the height difference between the left and right subtrees (called balance factor) of any node is at most 1.</p>
    <p><strong>Problem:</strong> Unbalanced BSTs lead to inefficient operations.</p>
    <p><strong>Optimization:</strong> AVL trees automatically balance themselves during insertions and deletions, ensuring that all operations remain O(log n). However, balancing operations (rotations) can slightly impact performance.</p>

    <h5>4. 2-3 Tree</h5>
    <p><strong>Structure:</strong> A 2-3 tree is a balanced tree where each node can have 2 or 3 children, and the tree remains perfectly balanced (all leaves are at the same level).</p>
    <p><strong>Problem:</strong> Maintaining balance and ordering in dynamic data can be difficult.</p>
    <p><strong>Optimization:</strong> The 2-3 tree maintains balance by splitting and merging nodes during insertions and deletions. It guarantees logarithmic time complexity for search, insertion, and deletion (O(log n)).</p>

    <h5>5. Red-Black Tree</h5>
    <p><strong>Structure:</strong> A red-black tree is a self-balancing binary search tree with an additional constraint on the colors of nodes (either red or black). This structure ensures that the tree remains approximately balanced.</p>
    <p><strong>Problem:</strong> Keeping a binary search tree balanced while allowing quick insertion and deletion.</p>
    <p><strong>Optimization:</strong> Red-black trees offer good performance with O(log n) operations for search, insert, and delete. The red-black tree is more relaxed than an AVL tree, offering faster insertions and deletions at the cost of slightly less strict balancing.</p>

    <h5>6. Heap (Binary Heap)</h5>
    <p><strong>Structure:</strong> A binary heap is a complete binary tree where the parent node is either greater than (max heap) or smaller than (min heap) its child nodes.</p>
    <p><strong>Problem:</strong> Finding the maximum or minimum element efficiently.</p>
    <p><strong>Optimization:</strong> Heaps are optimized for efficient priority queue operations. Operations like insertions and deletions take O(log n), while finding the max or min element takes O(1).</p>

    <h5>7. Trie (Prefix Tree)</h5>
    <p><strong>Structure:</strong> A trie is a tree-like data structure that stores strings. Each node represents a common prefix of some strings. It is particularly useful for handling large dictionaries or performing efficient prefix searches.</p>
    <p><strong>Problem:</strong> Storing and searching for strings, especially when working with large datasets like dictionaries.</p>
    <p><strong>Optimization:</strong> Tries allow fast lookups (O(m), where m is the length of the string) for both exact matching and prefix matching, making them ideal for applications like autocomplete, spell checkers, and dictionary searches.</p>

    <h4>&bull; &nbsp;4.The need of array query algorithms and their implications. Their applications and principles need to be discussed</h4>
    <h5>What Are Array Query Algorithms?</h5>
    <ul>
      <li>Find the sum of a few numbers in the list.</li>
      <li>Find the biggest or smallest number in a section of the list.</li>
      <li>Update a number in the list.</li>
    </ul>
    <h5>Why Do We Need These Algorithms?</h5>
    <ul>
      <li><strong>Speed: Without these algorithms, you'd have to check every number in the list, which can be slow, especially if you're asking the same question many times.</li>
      <li><strong>Efficiency: These algorithms make sure that even with huge lists, you can get the answer in a fraction of the time. This is important for things like real-time applications or large datasets.</li>
    </ul>
    <h5>Types of Array Query Algorithms:</h5>
    <h5>1.Prefix Sum (Cumulative Sum):</h5>
    <ul>
      <li><strong>What it does: It makes a new list where each element shows the total sum of all the numbers from the start to that point.</li>
      <li><strong>Why it's useful: Once you have this list, you can easily find the sum of any part of the original list. Instead of adding numbers one by one every time, you can find the sum in an instant.</li>
      <li>Example: Want the sum of numbers between position 3 and position 5? With prefix sums, you can get it right away.</li>
    </ul>
    <h5>2.Segment Tree:</h5>
    <ul>
      <li><strong>What it does: This is like a tree that helps you manage data in sections. Each section of the tree has a piece of your array, and you can quickly ask it for sums, maximums, or minimums in that section.</li>
      <li><strong>Why it's useful: If you're often asking about a part of the list (like the sum or max in a range), the segment tree helps answer those questions super fast.</li>
      <li>Example: In a game, if you want to know the highest score between levels 10 and 20, a segment tree can give you that quickly.</li>
    </ul>
    <h5>3.Binary Indexed Tree (BIT):</h5>
    <ul>
      <li><strong>What it does: It’s another way to store sums, but it’s designed for when you're updating the list and still need to do fast queries.</li>
      <li><strong>Why it's useful: If the list changes often and you still need quick answers, BIT helps balance the need for updates and queries efficiently.</li>
      <li>Example: Updating scores in a leaderboard and then asking for the total score quickly.</li>
    </ul>
    <h5>4.Sparse Table:</h5>
    <ul>
      <li><strong>What it does: This is for when the list doesn’t change much. It’s great for quickly answering questions like "What’s the smallest number in this part of the list?"</li>
      <li><strong>Why it's useful: It's super fast at answering these questions, but only if the list doesn’t change often.</li>
      <li>Example: Finding the lowest temperature in a city for the past month, if the data is mostly static.</li>
    </ul>
    <h5>Where Are These Algorithms Used?</h5>
    <ul>
      <li><strong>Financial Data: When you need to quickly calculate the sum of sales, stock prices, or transactions over a certain period, these algorithms can help you do it efficiently.</li>
      <li><strong>Gaming: If you’re keeping track of scores or health points and want to quickly know totals or maximums across levels, these algorithms can make those queries faster.</li>
      <li><strong>Search Engines: They help in answering complex queries about data stored in databases quickly.</li>
      <li><strong>Real-Time Systems: These algorithms are perfect when you need instant feedback, like in tracking real-time data (e.g., live sports scores).</li>
    </ul>
    <h5>How Do These Algorithms Work?</h5>
    <ul>
      <li><strong>Preprocessing: Some algorithms (like prefix sum) need you to set them up first by processing the whole list. Once that's done, you can get answers quickly whenever you need them.</li>
      <li><strong>Efficient Searching: Some algorithms (like segment trees or BITs) allow you to find answers to questions (like sum or max) in just a few steps, even if the list is huge.</li>
      <li><strong>Updating Data: For lists that change often, these algorithms let you update a number in the list quickly while still letting you ask questions efficiently.</li>
    </ul>
    <h4>&bull; &nbsp;Differentiate between tree and graphs and their traversals. The applications of each</h4>
    <h5>1.Structure:</h5>
    <ul>
      <li><strong>Trees: Think of a tree like a family tree. There’s one main person at the top (the root), and everyone else below them is connected in a clear parent-child relationship. Trees don’t have loops or shortcuts. Every child has one parent only.</li>
      <li><strong>Graphs: A graph is more like a road map. Cities (nodes) are connected by roads (edges), and you can have multiple ways to travel between cities. Graphs can have loops or paths that go in circles.</li>
    </ul>
    <h5>2.Connection:</h5>
    <ul>
      <li><strong>Trees: A tree is a special kind of graph that is always connected, meaning you can reach every node from the root without loops.</li>
      <li><strong>Graphs: Graphs are more general. They can have loops, disconnected pieces, or multiple paths.</li>
    </ul>
    <h5>How Do We Move Through Them?</h5>
    <h5>Tree Traversals (Visiting All Nodes in a Tree):</h5>
    <ul>
      <li><strong>Pre-order (Top to Bottom): Visit the root first, then explore left, and finally the right.</li>
      <li><strong>In-order (Left to Right): Visit the left, then the root, and finally the right. This is great for things like sorting numbers.</li>
      <li><strong>Post-order (Bottom to Top): Visit the left, then the right, and then the root. Useful for tasks like deleting a tree.</li>
      <li><strong>Level-order (Layer by Layer): Start at the top (root) and visit level by level, like reading a book one line at a time.</li>
    </ul>
    <h5>Graph Traversals (Visiting All Nodes in a Graph):</h5>
    <ul>
      <li><strong>Depth-First Search (DFS): Think of it like exploring a maze—go as far as you can down one path, and if you hit a dead end, backtrack and try another.</li>
      <li><strong>Breadth-First Search (BFS): Explore all the nearby places first before moving further away, like checking all the rooms on one floor before going to the next floor.</li>
    </ul>
    <h5>Where Are Trees and Graphs Used?</h5>
    <h5>Applications of Trees:</h5>
    <ul>
      <li><strong>1.Organizing Information:</li>
      <ul><strong>File systems on your computer (folders and subfolders).</ul>
      <ul><strong>Family trees.</ul>
      <li><strong>2.Searching Fast:</li>
      <ul><strong>Binary Search Trees (BST) help you quickly find items (e.g., searching for a word in a dictionary).</ul>
      <li><strong>3.Game Strategies:</li>
      <ul><strong>AI uses trees to make decisions in games like chess or tic-tac-toe.</ul>
      <li><strong>4.Parsing Data:</li>
      <ul><strong>Trees help programs understand formulas like 5 + (3 * 2).</ul>
    </ul>
    <h5>Applications of Graphs:</h5>
    <ul>
      <li>1.Social Networks:</li>
      <ul>People are nodes, and friendships are connections.</ul>
      <li>2.Maps:</li>
      <ul>Cities are nodes, and roads are edges. GPS uses graphs to find the shortest path.</ul>
      <li>3.Internet:</li>
      <ul>Websites are nodes, and links are edges. Search engines analyze graphs to rank pages.</ul>
      <li>4.Routing Networks:</li>
      <ul>Graphs help route data in computer networks or optimize delivery routes.</ul>
    </ul>
    <h4>Deliberate on sorting and searching algorithms, the technique behind each and they connect to real world</h4>
    <h5>Sorting Algorithms (Organizing Things)</h5>
    <h5>1.Bubble Sort:</h5>
    <ul>
      <li>How it works: Look at two items at a time. If they’re out of order, swap them. Keep doing this until everything is sorted.</li>
      <li><strong>Example in real life: Comparing two books on your desk, swapping them if one is bigger, and repeating until your desk is neat.</li>
      <li>Drawback: It’s slow—good only for small tasks.</li>
    </ul>
    <h5>2.Selection Sort:</h5>
    <ul>
      <li>How it works: Look through everything, pick the smallest item, and move it to the front. Repeat until sorted.</li>
      <li><strong>Example in real life: Sorting your pens by size by picking the shortest one first, then the next shortest, and so on.</li>
    </ul>
    <h5>3.Insertion Sort:</h5>
    <ul>
      <li>How it works: Take one item at a time and insert it into the correct position in an already sorted section.</li>
      <li>Example in real life: Sorting cards in your hand while playing rummy.</li>
    </ul>
    <h5>4.Merge Sort:</h5>
    <ul>
      <li>How it works: Divide your pile into small groups, sort each group, and then combine them into one sorted pile.</li>
      <li>Example in real life: If you have a lot of papers, you might split them into smaller stacks, organize each stack, and then merge them back together.</li>
    </ul>
    <h5>5.Quick Sort:</h5>
    <ul>
      <li>How it works: Pick a random item as the “pivot.” Separate everything smaller than the pivot to one side and everything larger to the other. Repeat until sorted.</li>
      <li>Example in real life: Sorting clothes in your wardrobe—pick one item (e.g., a shirt), separate clothes into “smaller” (socks) and “bigger” (jackets), and continue.</li>
    </ul>
     <h5>Searching Algorithms (Finding Things)</h5>
    <h5>1.Linear Search:</h5>
    <ul>
      <li>How it works: Check every item one by one until you find what you’re looking for.</li>
      <li>Example in real life: Looking for a specific pen by checking each one in a pile.</li>
      <li>Drawback: It’s slow if there’s a lot to search through.</li>
    </ul>
    <h5>2.Binary Search (When Things Are Sorted):</h5>
    <ul>
      <li>How it works: Start in the middle of the list. If the item you want is smaller, look at the left half; if it’s larger, look at the right half. Repeat until you find it.</li>
      <li>Example in real life: Looking up a word in a dictionary—you flip to the middle, check where you are, and narrow it down quickly.</li>
      <li>Faster than linear search, but your items must be sorted first.</li>
    </ul>
    <h5>3.Hashing (Super Fast):</h5>
    <ul>
      <li>How it works: Convert your item (like a name) into a unique “address” and jump straight to it.</li>
      <li>Example in real life: Using your friend’s house address to go directly to their home instead of checking every house on the street.</li>
      <li>Used in: Password systems, phone books, and online databases.</li>
    </ul>
    <h4>Discuss the importance of graph algorithms with respect to spanning trees and shortest paths</h4>
    
  </div>
</body>
</html>
